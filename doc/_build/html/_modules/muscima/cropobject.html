<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>muscima.cropobject &#8212; muscima 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="muscima 0.3.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for muscima.cropobject</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module implements a Python representation of the CropObject,</span>
<span class="sd">the basic unit of annotation. See the :class:`CropObject` documentation.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Jan Hajic jr.&quot;</span>


<span class="n">CROPOBJECT_MASK_ORDER</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>
<span class="c1">#: The CropObject mask uses this numpy ordering when flattening the data.</span>

<span class="c1">##############################################################################</span>


<div class="viewcode-block" id="CropObject"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject">[docs]</a><span class="k">class</span> <span class="nc">CropObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;One annotated object.</span>

<span class="sd">    The CropObject represents one instance of an annotation. It implements</span>
<span class="sd">    the following attributes:</span>

<span class="sd">    * ``objid``: the unique number of the given annotation instance in the set</span>
<span class="sd">      of annotations encoded in the containing `CropObjectList`.</span>
<span class="sd">    * ``uid``: the global unique identifier of the annotation instance. String.</span>
<span class="sd">      See :meth:`CropObject.parse_uid` method for format details.</span>
<span class="sd">    * ``clsname``: the name of the label that was given to the annotation</span>
<span class="sd">      (this is the human-readable string such as ``notehead-full``).</span>
<span class="sd">    * ``top``: the vertical dimension (row) of the upper left corner pixel.</span>
<span class="sd">    * ``left``: the horizontal dimension (column) of the upper left corner pixel.</span>
<span class="sd">    * ``bottom``: the vertical dimension (row) of the lower right corner pixel + 1,</span>
<span class="sd">      so that you can index the corresponding image rows using</span>
<span class="sd">      ``img[c.top:c.bottom]``.</span>
<span class="sd">    * ``right``: the horizontal dimension (row) of the lower right corner pixel + 1,</span>
<span class="sd">      so that you can index the corresponding image columns using</span>
<span class="sd">      ``img[:, c.left:c.right]``.</span>
<span class="sd">    * ``width``: the amount of rows that the CropObject spans.</span>
<span class="sd">    * ``height``: the amount of columns that the CropObject spans.</span>
<span class="sd">    * ``mask``: a binary (0/1) numpy array that denotes the area within the</span>
<span class="sd">      CropObject&#39;s bounding box (specified by ``top``, ``left``, ``height``</span>
<span class="sd">      and ``width``) that the CropObject actually occupies. If the mask is</span>
<span class="sd">      ``None``, the object is understood to occupy the entire bounding box.</span>

<span class="sd">    Constructing a simple CropObject that consists of the &quot;b&quot;-like flat music</span>
<span class="sd">    notation symbol (never mind the ``uid`` for now):</span>

<span class="sd">    &gt;&gt;&gt; top = 10</span>
<span class="sd">    &gt;&gt;&gt; left = 15</span>
<span class="sd">    &gt;&gt;&gt; height = 10</span>
<span class="sd">    &gt;&gt;&gt; width = 4</span>
<span class="sd">    &gt;&gt;&gt; mask = numpy.array([[1, 1, 0, 0],</span>
<span class="sd">    ...                     [1, 0, 0, 0],</span>
<span class="sd">    ...                     [1, 0, 0, 0],</span>
<span class="sd">    ...                     [1, 0, 0, 0],</span>
<span class="sd">    ...                     [1, 0, 1, 1],</span>
<span class="sd">    ...                     [1, 1, 1, 1],</span>
<span class="sd">    ...                     [1, 0, 0, 1],</span>
<span class="sd">    ...                     [1, 0, 1, 1],</span>
<span class="sd">    ...                     [1, 1, 1, 0],</span>
<span class="sd">    ...                     [0, 1, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; clsname = &#39;flat&#39;</span>
<span class="sd">    &gt;&gt;&gt; uid = &#39;MUSCIMA++_1.0___muscima.cropobject.CropObject.doctest___0&#39;</span>
<span class="sd">    &gt;&gt;&gt; c = CropObject(objid=0, clsname=clsname,</span>
<span class="sd">    ...                top=top, left=left, height=height, width=width,</span>
<span class="sd">    ...                inlinks=[], outlinks=[],</span>
<span class="sd">    ...                mask=mask,</span>
<span class="sd">    ...                uid=uid)</span>

<span class="sd">    CropObjects can also form graphs, using the following attributes:</span>

<span class="sd">    * ``outlinks``: Outgoing edges. A list of integers; it is assumed they are</span>
<span class="sd">      valid ``objid`` within the same global/doc namespace.</span>
<span class="sd">    * ``inlinks``: Incoming edges. A list of integers; it is assumed they are</span>
<span class="sd">      valid ``objid`` within the same global/doc namespace.</span>

<span class="sd">    So far, CropObject graphs do not support multiple relationship types.</span>

<span class="sd">    **Unique identification**</span>

<span class="sd">    The ``uid`` serves to identify the CropObject uniquely,</span>
<span class="sd">    at least within the MUSCIMA dataset system. (We anticipate further</span>
<span class="sd">    versions of the dataset, and need to plan for that.)</span>

<span class="sd">    To uniquely identify a CropObject, we need three &quot;levels&quot;:</span>

<span class="sd">    * The &quot;global&quot;, **dataset-level identification**: which dataset is this</span>
<span class="sd">      CropObject coming from? (For this dataset: ``MUSCIMA++_1.0``)</span>
<span class="sd">    * The &quot;local&quot;, **document-level identification**: which document</span>
<span class="sd">      (within the given dataset) is this CropObject coming from?</span>
<span class="sd">      For MUSCIMA++ 1.0, this will usually be a string like</span>
<span class="sd">      ``CVC-MUSCIMA_W-35_N-08_D-ideal``, derived from the filename</span>
<span class="sd">      under which the CropObjectList containing the given CropObject</span>
<span class="sd">      is stored.</span>
<span class="sd">    * The **within-document identification**, which is identical</span>
<span class="sd">      to the ``objid``.</span>

<span class="sd">    These three components are joined together into one string by</span>
<span class="sd">    a delimiter: ``___``</span>

<span class="sd">    The full ``uid`` of a CropObject then might look like this::</span>

<span class="sd">      MUSCIMA-pp_1.0___CVC-MUSCIMA_W-35_N-08_D-ideal___611</span>

<span class="sd">    You will need to use UIDs whenever you are combining CropObjects</span>
<span class="sd">    from different documents, and/or datasets. (If you are really combining</span>
<span class="sd">    datasets, make sure you know what you are doing -- some annotation</span>
<span class="sd">    instructions may change between versions, so objects of the same class</span>
<span class="sd">    might not exactly correspond to each other...) The dataset and document</span>
<span class="sd">    names are available through appropriate instance attributes:</span>

<span class="sd">    &gt;&gt;&gt; c.doc</span>
<span class="sd">    &#39;muscima.cropobject.CropObject.doctest&#39;</span>
<span class="sd">    &gt;&gt;&gt; c.dataset</span>
<span class="sd">    &#39;MUSCIMA++_1.0&#39;</span>

<span class="sd">    If you supply no ``uid`` at initialization time, a default UID will</span>
<span class="sd">    be used:</span>

<span class="sd">    &gt;&gt;&gt; c.default_uid</span>
<span class="sd">    &#39;MUSCIMA_DEFAULT_DATASET_PLACEHOLDER___default-document___0&#39;</span>

<span class="sd">    (Don&#39;t abuse the default, though! It&#39;s intended just for transitioning</span>
<span class="sd">    documents without UIDs to those that have them.)</span>

<span class="sd">    On the other hand, the ``objid`` is a field intended to uniquely identify</span>
<span class="sd">    a CropObject within the scope of one CropObject list (one annotation</span>
<span class="sd">    document).</span>

<span class="sd">    .. caution::</span>

<span class="sd">        The scope of unique identification within MUSCIMA++ is only within</span>
<span class="sd">        a ``&lt;CropObjectList&gt;``. Don&#39;t use ``objid`` to mix CropObjects from</span>
<span class="sd">        multiple files!</span>

<span class="sd">    **CropObjects and images**</span>

<span class="sd">    CropObjects and images are not tightly bound. This is because the same</span>
<span class="sd">    object can apply to multiple images: in the case of the CVC-MUSCIMA dataset,</span>
<span class="sd">    for example, the same CropObjects are present both in the full image</span>
<span class="sd">    and in the staff-less image. The limitation here is that CropObjects</span>
<span class="sd">    are based on exact pixels, so in order to retain validity, the images</span>
<span class="sd">    must correspond to each other exactly, as &quot;layers&quot;.</span>

<span class="sd">    Because CropObjects do not correspond to any given image, there is</span>
<span class="sd">    no facility in the data format to link them to a specific one. You have to</span>
<span class="sd">    take care of matching CropObject annotations to the right images by yourself.</span>

<span class="sd">    The ``CropObject`` class implements some interactions with images.</span>

<span class="sd">    To recover the area corresponding to a CropObject `c`, use:</span>

<span class="sd">    &gt;&gt;&gt; if c.mask is not None: crop = img[c.top:c.bottom, c.left:c.right] * c.mask  #doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; if c.mask is None: crop = img[c.top:c.bottom, c.left:c.right]               #doctest: +SKIP</span>

<span class="sd">    Because this is clunky, we have implemented the following to get the crop:</span>

<span class="sd">    &gt;&gt;&gt; crop = c.project_to(img)    #doctest: +SKIP</span>

<span class="sd">    And to get the CropObject projected onto the entire image:</span>

<span class="sd">    &gt;&gt;&gt; crop = c.project_on(img)    #doctest: +SKIP</span>

<span class="sd">    Above, note the multiplicative role of the mask: while we typically would</span>
<span class="sd">    expect the mask to be binary, in principle, this is not strictly necessary.</span>
<span class="sd">    You could supply a different mask interpration, such as probabilistic.</span>
<span class="sd">    However, we strongly advise not to misuse this feature unless you have</span>
<span class="sd">    a really good reason; remember that the CropObject is supposed to represent</span>
<span class="sd">    an annotation of a given image. (One possible use for a non-binary mask</span>
<span class="sd">    that we can envision is aggregating multiple annotations of the same</span>
<span class="sd">    image.)</span>

<span class="sd">    For visualization, there is a more sophisticated method that renders</span>
<span class="sd">    the CropObject as a transparent colored transparent rectangle over</span>
<span class="sd">    an RGB image. (NOTE: this really changes the input image!)</span>

<span class="sd">    &gt;&gt;&gt; c_obj.render(img)           #doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(img); plt.show() #doctest: +SKIP</span>

<span class="sd">    However, `CropObject.render()` currently does not support rendering</span>
<span class="sd">    the mask.</span>

<span class="sd">    **Disambiguating class names**</span>

<span class="sd">    Since the class names are present</span>
<span class="sd">    through the ``clsname`` attribute (``&lt;MLClassName&gt;`` element),</span>
<span class="sd">    matching the list is no longer necessary for general understanding</span>
<span class="sd">    of the file. The MLClassList file serves as a disambiguation tool:</span>
<span class="sd">    there may be multiple annotation projects that use the same names</span>
<span class="sd">    but maybe define them differently and use different guidelines,</span>
<span class="sd">    and their respective MLClassLists allow you to interpret the symbol</span>
<span class="sd">    names correctly, in light of the corresponding set of definitions.</span>

<span class="sd">    .. note::</span>

<span class="sd">        In MUSCIMarker, the MLClassList is currently necessary to define</span>
<span class="sd">        how CropObjects are displayed: their color. (All noteheads are red,</span>
<span class="sd">        all barlines are green, etc.) The other function, matching names</span>
<span class="sd">        to ``clsid``, has been superseeded by the ``clsname`` CropObject</span>
<span class="sd">        attribute.</span>

<span class="sd">    **Merging CropObjects**</span>

<span class="sd">    To merge a list of CropObjects into a new one, you need to:</span>

<span class="sd">    * Compute the new object&#39;s bounding box: ``croobjects_merge_bbox()``</span>
<span class="sd">    * Compute the new object&#39;s mask: ``cropobjects_merge_mask()``</span>
<span class="sd">    * Determine the clsid and objid of the new object.</span>

<span class="sd">    Since objid and clsid of merges may depend on external settings</span>
<span class="sd">    and generally cannot be reliably determined from the merged</span>
<span class="sd">    objects themselves (e.g. the merge of a notehead and a stem</span>
<span class="sd">    should be a new note symbol), you need to supply them externally.</span>
<span class="sd">    However, the bounding box and mask can be determined. The bounding</span>
<span class="sd">    box is computed simply as the smallest bounding box that</span>
<span class="sd">    encompasses all the CropObjects, and the mask is an OR operation</span>
<span class="sd">    over the individual masks (or None, if the CropObjects don&#39;t</span>
<span class="sd">    have masks). Note that the merge cannot deal with a situation</span>
<span class="sd">    where only some of the objects have a mask.</span>

<span class="sd">    **Implementation notes on the mask**</span>

<span class="sd">    The mask is a numpy array that will be saved using run-length encoding.</span>
<span class="sd">    The numpy array is first flattened, then runs of successive 0&#39;s and 1&#39;s</span>
<span class="sd">    are encoded as e.g. ``0:10`` for a run of 10 zeros.</span>

<span class="sd">    How much space does this take?</span>

<span class="sd">    Objects tend to be relatively convex, so after flattening, we can expect</span>
<span class="sd">    more or less two runs per row (flattening is done in ``C`` order). Because</span>
<span class="sd">    each run takes (approximately) 5 characters, each mask takes roughly ``5 * n_rows``</span>
<span class="sd">    bytes to encode. This makes it efficient for objects wider than 5 pixels, with</span>
<span class="sd">    a compression ratio approximately ``n_cols / 5``.</span>
<span class="sd">    (Also, the numpy array needs to be made C-contiguous for that, which</span>
<span class="sd">    explains the ``order=&#39;C&#39;`` hack in ``set_mask()``.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objid</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
                 <span class="n">outlinks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inlinks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">uid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing CropObject with objid </span><span class="si">{0}</span><span class="s1">, uid </span><span class="si">{5}</span><span class="s1">, x=</span><span class="si">{1}</span><span class="s1">,&#39;</span>
                     <span class="s1">&#39; y=</span><span class="si">{2}</span><span class="s1">, h=</span><span class="si">{3}</span><span class="s1">, w=</span><span class="si">{4}</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">objid</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">uid</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objid</span> <span class="o">=</span> <span class="n">objid</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clsname</span> <span class="o">=</span> <span class="n">clsname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">top</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to_integer_bounds</span><span class="p">()</span>

        <span class="c1"># The mask presupposes integer bounds.</span>
        <span class="c1"># Applied relative to CropObject bounds, not the whole image.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inlinks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inlinks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span> <span class="o">=</span> <span class="n">inlinks</span>

        <span class="k">if</span> <span class="n">outlinks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outlinks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span> <span class="o">=</span> <span class="n">outlinks</span>

        <span class="c1"># Deal with the UID</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_uid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_uid</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_selected</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#logging.debug(&#39;...done!&#39;)</span>

    <span class="c1">##########################################################################</span>
    <span class="c1"># Dealing with unique identification of a CropObject, also across</span>
    <span class="c1"># anticipated dataset versions.</span>

    <span class="n">UID_DELIMITER</span> <span class="o">=</span> <span class="s1">&#39;___&#39;</span>
    <span class="c1">#: Delimits the CropObject UID fields (global, document namespaces, objid)</span>

    <span class="n">UID_DEFAULT_DATASET_NAMESPACE</span> <span class="o">=</span> <span class="s1">&#39;MUSCIMA_DEFAULT_DATASET_PLACEHOLDER&#39;</span>
    <span class="c1">#: Default dataset name for CropObjects.</span>

    <span class="n">UID_DEFAULT_DOCUMENT_NAMESPACE</span> <span class="o">=</span> <span class="s1">&#39;default-document&#39;</span>
    <span class="c1">#: Default document name for CropObjects.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_uid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs the default ``uid`` that the CropObject would</span>
<span class="sd">        have, unless one was supplied at initialization.</span>

<span class="sd">        &gt;&gt;&gt; c.default_uid</span>
<span class="sd">        &#39;MUSCIMA_DEFAULT_DATASET_PLACEHOLDER___default-document___0&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">UID_DELIMITER</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">UID_DEFAULT_DATASET_NAMESPACE</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">UID_DEFAULT_DOCUMENT_NAMESPACE</span><span class="p">,</span>
                                        <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">)])</span>

<div class="viewcode-block" id="CropObject.parse_uid"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.parse_uid">[docs]</a>    <span class="k">def</span> <span class="nf">parse_uid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the unique identifier of the CropObject. This</span>
<span class="sd">        breaks down the UID into the global namespace, document</span>
<span class="sd">        namespace (ie. CropObjectList name -- usually per image),</span>
<span class="sd">        and the numeric ID of the CropObject within one CropObjectList.</span>
<span class="sd">        This numeric ID should always match the ``objid``, which</span>
<span class="sd">        acts as the &quot;technical&quot; identifier, since it is known to be</span>
<span class="sd">        an integer and therefore usable for e.g. indexing within</span>
<span class="sd">        the MUSCIMarker annotation app.</span>

<span class="sd">        See :meth:`_parse_uid` for format &amp; test. Compared</span>
<span class="sd">        to :meth:`_parse_uid`, this method checks the parsed ``num``</span>
<span class="sd">        in the ``uid`` against this CropObject&#39;s ``objid``,</span>
<span class="sd">        to verify that the UID is really valid for this object.</span>

<span class="sd">        The delimiter is expected to be ``___``</span>
<span class="sd">        (kept as ``CropObject.UID_DELIMITER``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gn</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_uid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span>
        <span class="c1"># Dealing with missing uid</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objid</span>

        <span class="k">if</span> <span class="n">num</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Got CropObject with different numeric ID&#39;</span>
                             <span class="s1">&#39; in UID and technical objid. UID record:&#39;</span>
                             <span class="s1">&#39; </span><span class="si">{0}</span><span class="s1">, objid: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">gn</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">num</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_uid</span><span class="p">(</span><span class="n">uid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse the unique identifier of the CropObject. This</span>
<span class="sd">        breaks down the UID into the global namespace, document</span>
<span class="sd">        namespace (ie. CropObjectList name -- usually per image),</span>
<span class="sd">        and the numeric ID of the CropObject within one CropObjectList.</span>

<span class="sd">        The delimiter is expected to be ``___``</span>
<span class="sd">        (kept as ``CropObject.UID_DELIMITER``)</span>

<span class="sd">        &gt;&gt;&gt; CropObject._parse_uid(&#39;MUSCIMA++_1.0___CVC-MUSCIMA_W-05_N-19_D-ideal___424&#39;)</span>
<span class="sd">        (&#39;MUSCIMA++_1.0&#39;, &#39;CVC-MUSCIMA_W-05_N-19_D-ideal&#39;, 424)</span>

<span class="sd">        :returns: ``global_namespace, document_namespace, objid`` triplet.</span>
<span class="sd">            The namespaces are strings, ``objid`` is an integer. If ``uid``</span>
<span class="sd">            is ``None``, returns ``None`` as ``objid`` and expects it</span>
<span class="sd">            to be filled in from the caller CropObject instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">global_name</span> <span class="o">=</span> <span class="n">CropObject</span><span class="o">.</span><span class="n">UID_DEFAULT_DATASET_NAMESPACE</span>
            <span class="n">document_name</span> <span class="o">=</span> <span class="n">CropObject</span><span class="o">.</span><span class="n">UID_DEFAULT_DOCUMENT_NAMESPACE</span>
            <span class="n">numid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">global_name</span><span class="p">,</span> <span class="n">document_name</span><span class="p">,</span> <span class="n">numid_str</span> <span class="o">=</span> <span class="n">uid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">CropObject</span><span class="o">.</span><span class="n">UID_DELIMITER</span><span class="p">)</span>
            <span class="n">numid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numid_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">global_name</span><span class="p">,</span> <span class="n">document_name</span><span class="p">,</span> <span class="n">numid</span>

<div class="viewcode-block" id="CropObject.set_uid"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.set_uid">[docs]</a>    <span class="k">def</span> <span class="nf">set_uid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assigns the given ``uid`` to the CropObject. This is the way</span>
<span class="sd">        to do it, do not assign directly to ``cropobject.uid``! You need</span>
<span class="sd">        to update other things (and perform integrity checks) when changing</span>
<span class="sd">        the unique ID! See :class:`CropObject` class documentation for</span>
<span class="sd">        information on how ``uid`` attributes work.</span>

<span class="sd">        Do **NOT** use this function, unless you know what you are doing!</span>
<span class="sd">        You could mess up the integrity of your copy of the dataset, and</span>
<span class="sd">        you&#39;d have to download it again...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_namespace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_document_namespace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">parse_uid</span><span class="p">()</span></div>

<div class="viewcode-block" id="CropObject.set_mask"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.set_mask">[docs]</a>    <span class="k">def</span> <span class="nf">set_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the CropObject&#39;s mask to the given array. Performs</span>
<span class="sd">        some compatibilty checks: size, dtype (converts to ``uint8``).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check dimension</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_to_integer_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span><span class="c1">#.count()</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mask shape </span><span class="si">{0}</span><span class="s1"> does not correspond&#39;</span>
                                 <span class="s1">&#39; to integer shape </span><span class="si">{1}</span><span class="s1"> of CropObject.&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">!=</span> <span class="s1">&#39;uint8&#39;</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;CropObject.set_mask(): Supplied non-integer mask&#39;</span>
                              <span class="s1">&#39; with dtype=</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Which dataset is this CropObject coming from?</span>
<span class="sd">        For bookkeeping.&quot;&quot;&quot;</span>
        <span class="c1"># The ``_dataset_namespace`` is set during initialization.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataset_namespace</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">doc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Which document within the dataset is this CropObject</span>
<span class="sd">        coming from? The ``_document_namespace``</span>

<span class="sd">        This is important when working with CropObjects</span>
<span class="sd">        from multiple CropObjectList files, especially for properly</span>
<span class="sd">        constructing CropObject graphs, because ``inlinks`` and</span>
<span class="sd">        ``outlinks`` use the numeric ``objids``, which point to</span>
<span class="sd">        CropObjects within the same document.</span>

<span class="sd">        ``objid`` of each CropObject has to be unique within a document.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The ``_document_namespace`` is set during initialization.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_document_namespace</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Row coordinate of upper left corner.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bottom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Row coordinate 1 beyond bottom right corner, so that indexing</span>
<span class="sd">        in the form ``img[c.top:c.bottom]`` is possible.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Column coordinate of upper left corner.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Column coordinate 1 beyond bottom right corner, so that indexing</span>
<span class="sd">        in the form ``img[:, c.left:c.right]`` is possible.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_box</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The ``top, left, bottom, right`` tuple of the CropObject&#39;s</span>
<span class="sd">        coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">middle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the integer representation of where the middle</span>
<span class="sd">        of the CropObject lies, as a ``(m_vert, m_horz)`` tuple.</span>

<span class="sd">        The integers just get rounded down.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vmid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">hmid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">vmid</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">hmid</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A CropObject is empty if it is composed of zero pixels.</span>
<span class="sd">        This is measured through the mask. CropObjects without</span>
<span class="sd">        a mask are assumed to be non-empty.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CropObject.bbox_to_integer_bounds"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.bbox_to_integer_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">bbox_to_integer_bounds</span><span class="p">(</span><span class="n">ftop</span><span class="p">,</span> <span class="n">fleft</span><span class="p">,</span> <span class="n">fbottom</span><span class="p">,</span> <span class="n">fright</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rounds off the CropObject bounds to the nearest integer</span>
<span class="sd">        so that no area is lost (e.g. bottom and right bounds are</span>
<span class="sd">        rounded up, top and left bounds are rounded down).</span>

<span class="sd">        Returns the rounded-off integers (top, left, bottom, right)</span>
<span class="sd">        as integers.</span>

<span class="sd">        &gt;&gt;&gt; CropObject.bbox_to_integer_bounds(44.2, 18.9, 55.1, 92.99)</span>
<span class="sd">        (44, 18, 56, 93)</span>
<span class="sd">        &gt;&gt;&gt; CropObject.bbox_to_integer_bounds(44, 18, 56, 92.99)</span>
<span class="sd">        (44, 18, 56, 93)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;bbox_to_integer_bounds: inputs </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">ftop</span><span class="p">,</span> <span class="n">fleft</span><span class="p">,</span> <span class="n">fbottom</span><span class="p">,</span> <span class="n">fright</span><span class="p">)))</span>

        <span class="n">top</span> <span class="o">=</span> <span class="n">ftop</span> <span class="o">-</span> <span class="p">(</span><span class="n">ftop</span> <span class="o">%</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">fleft</span> <span class="o">-</span> <span class="p">(</span><span class="n">fleft</span> <span class="o">%</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">fbottom</span> <span class="o">-</span> <span class="p">(</span><span class="n">fbottom</span> <span class="o">%</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fbottom</span> <span class="o">%</span> <span class="mf">1.0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">+=</span> <span class="mf">1.0</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">fright</span> <span class="o">-</span> <span class="p">(</span><span class="n">fright</span> <span class="o">%</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fright</span> <span class="o">%</span> <span class="mf">1.0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">+=</span> <span class="mf">1.0</span>

        <span class="k">if</span> <span class="n">top</span> <span class="o">!=</span> <span class="n">ftop</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;bbox_to_integer_bounds: rounded top by </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">ftop</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="n">fleft</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;bbox_to_integer_bounds: rounded left by </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">fleft</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">bottom</span> <span class="o">!=</span> <span class="n">fbottom</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;bbox_to_integer_bounds: rounded bottom by </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">fbottom</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">!=</span> <span class="n">fright</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;bbox_to_integer_bounds: rounded right by </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">fright</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">bottom</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">)</span></div>

<div class="viewcode-block" id="CropObject.to_integer_bounds"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.to_integer_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">to_integer_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ensures that the CropObject has an integer position and size.</span>
<span class="sd">        (This is important whenever you want to use a mask, and reasonable</span>
<span class="sd">        whenever you do not need sub-pixel resolution...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bbox_to_integer_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">bbox</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">t</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span></div>

<div class="viewcode-block" id="CropObject.project_to"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.project_to">[docs]</a>    <span class="k">def</span> <span class="nf">project_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function returns the *crop* of the input image</span>
<span class="sd">        corresponding to the CropObject (incl. masking).</span>
<span class="sd">        Assumes zeros are background.&quot;&quot;&quot;</span>
        <span class="c1"># Make a copy! We don&#39;t want to modify the original image by the mask.</span>
        <span class="c1"># Copy forced by the &quot;* 1&quot; part.</span>
        <span class="n">crop</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">crop</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">return</span> <span class="n">crop</span></div>

<div class="viewcode-block" id="CropObject.project_on"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.project_on">[docs]</a>    <span class="k">def</span> <span class="nf">project_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function returns only those parts of the input image</span>
<span class="sd">        that correspond to the CropObject and masks out everything else</span>
<span class="sd">        with zeros. The dimension of the returned array is the same</span>
<span class="sd">        as of the input image. This function basically reconstructs</span>
<span class="sd">        the symbol as an indicator function over the pixels of</span>
<span class="sd">        the annotated image.&quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">crop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_to</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">crop</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="CropObject.render"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">rgb</span><span class="o">=</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Renders itself upon the given image as a rectangle</span>
<span class="sd">        of the given color and transparency. Might help visualization.</span>

<span class="sd">        :param img: A three-channel image (3-D numpy array,</span>
<span class="sd">            with the last dimension being 3).&quot;&quot;&quot;</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Rendering object </span><span class="si">{0}</span><span class="s1">, clsname </span><span class="si">{1}</span><span class="s1">, t/b/l/r: </span><span class="si">{2}</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clsname</span><span class="p">,</span>
                                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)))</span>
        <span class="c1"># logging.debug(&#39;Shape: {0}&#39;.format((self.height, self.width, 3)))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="n">color</span>
        <span class="n">crop</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span>
        <span class="c1"># logging.debug(&#39;Mask done, creating crop&#39;)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Shape: </span><span class="si">{0}</span><span class="s1">. Got crop. Crop shape: </span><span class="si">{1}</span><span class="s1">, img shape: </span><span class="si">{2}</span><span class="s1">&#39;</span>
                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">crop</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">mix</span> <span class="o">=</span> <span class="p">(</span><span class="n">crop</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">mask</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="n">img</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">mix</span>
        <span class="k">return</span> <span class="n">img</span></div>

<div class="viewcode-block" id="CropObject.overlaps"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether this CropObject overlaps the given bounding box.</span>

<span class="sd">        &gt;&gt;&gt; c = CropObject(0, &#39;test&#39;, 10, 100, height=20, width=10)</span>
<span class="sd">        &gt;&gt;&gt; c.bounding_box</span>
<span class="sd">        (10, 100, 30, 110)</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((10, 100, 30, 110))  # Exact match</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((0, 100, 8, 110))    # Row mismatch</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((10, 0, 30, 89))     # Column mismatch</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((0, 0, 8, 89))       # Total mismatch</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((9, 99, 31, 111))    # Encompasses CropObject</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((11, 101, 29, 109))  # Within CropObject</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((9, 101, 31, 109))   # Encompass horz., within vert.</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((11, 99, 29, 111))   # Encompasses vert., within horz.</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((11, 101, 31, 111))  # Corner within: top left</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((11, 99, 31, 109))   # Corner within: top right</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((9, 101, 29, 111))   # Corner within: bottom left</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c.overlaps((9, 99, 29, 109))    # Corner within: bottom right</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="c1"># Does it overlap vertically? Includes situations where the CropObject is</span>
        <span class="c1"># inside the bounding box.</span>
        <span class="c1"># Note that the bottom is +1 (fencepost), so the checks bottom vs. top need to be &quot;less than&quot;,</span>
        <span class="c1"># not leq. If one object&#39;s top would be equal to the other&#39;s bottom, they would be touching,</span>
        <span class="c1"># not overlapping.</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="CropObject.bbox_intersection"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.bbox_intersection">[docs]</a>    <span class="k">def</span> <span class="nf">bbox_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the sub-bounding box of this CropObject, relative to its size (so: 0,0</span>
<span class="sd">        is the CropObject&#39;s upper left corner), that intersects the given bounding box.</span>
<span class="sd">        If the intersection is empty, returns None.</span>

<span class="sd">        &gt;&gt;&gt; c = CropObject(0, &#39;test&#39;, 10, 100, height=20, width=10)</span>
<span class="sd">        &gt;&gt;&gt; c.bounding_box</span>
<span class="sd">        (10, 100, 30, 110)</span>
<span class="sd">        &gt;&gt;&gt; other_bbox = 20, 100, 40, 105</span>
<span class="sd">        &gt;&gt;&gt; c.bbox_intersection(other_bbox)</span>
<span class="sd">        (10, 0, 20, 5)</span>
<span class="sd">        &gt;&gt;&gt; containing_bbox = 4, 55, 44, 115</span>
<span class="sd">        &gt;&gt;&gt; c.bbox_intersection(containing_bbox)</span>
<span class="sd">        (0, 0, 20, 10)</span>
<span class="sd">        &gt;&gt;&gt; contained_bbox = 12, 102, 22, 108</span>
<span class="sd">        &gt;&gt;&gt; c.bbox_intersection(contained_bbox)</span>
<span class="sd">        (2, 2, 12, 8)</span>
<span class="sd">        &gt;&gt;&gt; non_overlapping_bbox = 0, 0, 3, 3</span>
<span class="sd">        &gt;&gt;&gt; c.bbox_intersection(non_overlapping_bbox) is None</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">bounding_box</span>

        <span class="n">out_top</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">out_bottom</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">)</span>
        <span class="n">out_left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">out_right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">out_top</span> <span class="o">&lt;</span> <span class="n">out_bottom</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">out_left</span> <span class="o">&lt;</span> <span class="n">out_right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">out_top</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> \
                   <span class="n">out_left</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> \
                   <span class="n">out_bottom</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> \
                   <span class="n">out_right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="CropObject.crop_to_mask"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.crop_to_mask">[docs]</a>    <span class="k">def</span> <span class="nf">crop_to_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crops itself to the minimum bounding box that contains all</span>
<span class="sd">        its pixels, as determined by its mask.</span>

<span class="sd">        If the mask is all zeros, does not do anything, because</span>
<span class="sd">        at this point, the is_empty check should be invoked anyway</span>
<span class="sd">        in any situation where you care whether the object is empty</span>
<span class="sd">        or not (e.g. delete it after trimming).</span>

<span class="sd">        &gt;&gt;&gt; mask = numpy.zeros((20, 10))</span>
<span class="sd">        &gt;&gt;&gt; mask[5:15, 3:8] = 1</span>
<span class="sd">        &gt;&gt;&gt; c = CropObject(0, &#39;test&#39;, 10, 100, width=10, height=20, mask=mask)</span>
<span class="sd">        &gt;&gt;&gt; c.bounding_box</span>
<span class="sd">        (10, 100, 30, 110)</span>
<span class="sd">        &gt;&gt;&gt; c.crop_to_mask()</span>
<span class="sd">        &gt;&gt;&gt; c.bounding_box</span>
<span class="sd">        (15, 103, 25, 108)</span>
<span class="sd">        &gt;&gt;&gt; c.height, c.width</span>
<span class="sd">        (10, 5)</span>

<span class="sd">        Assumes integer bounds, which is ensured during CropObject initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># We know the object is not empty.</span>

        <span class="c1"># How many rows/columns to trim from top, bottom, etc.</span>
        <span class="n">trim_top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trim_top</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

        <span class="n">trim_left</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trim_left</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">break</span>

        <span class="n">trim_bottom</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trim_bottom</span> <span class="o">=</span> <span class="n">k</span>
                <span class="k">break</span>

        <span class="n">trim_right</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[:,</span><span class="o">-</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trim_right</span> <span class="o">=</span> <span class="n">l</span>
                <span class="k">break</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Cropobject.crop: Trimming top=</span><span class="si">{0}</span><span class="s1">, left=</span><span class="si">{1}</span><span class="s1">,&#39;</span>
                     <span class="s1">&#39;bottom=</span><span class="si">{2}</span><span class="s1">, right=</span><span class="si">{3}</span><span class="s1">&#39;</span>
                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trim_top</span><span class="p">,</span> <span class="n">trim_left</span><span class="p">,</span> <span class="n">trim_bottom</span><span class="p">,</span> <span class="n">trim_right</span><span class="p">))</span>

        <span class="c1"># new bounding box relative to the current bounding box -- used to trim</span>
        <span class="c1"># the mask</span>
        <span class="n">rel_t</span> <span class="o">=</span> <span class="n">trim_top</span>
        <span class="n">rel_l</span> <span class="o">=</span> <span class="n">trim_left</span>
        <span class="n">rel_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">trim_bottom</span>
        <span class="n">rel_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">trim_right</span>

        <span class="n">new_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">rel_t</span><span class="p">:</span><span class="n">rel_b</span><span class="p">,</span> <span class="n">rel_l</span><span class="p">:</span><span class="n">rel_r</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Cropobject.crop: Old mask shape </span><span class="si">{0}</span><span class="s1">, new mask shape </span><span class="si">{1}</span><span class="s1">&#39;</span>
                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">new_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># new bounding box, relative to image -- used to compute the CropObject&#39;s</span>
        <span class="c1"># new position and size</span>
        <span class="n">abs_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">+</span> <span class="n">trim_top</span>
        <span class="n">abs_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="n">trim_left</span>
        <span class="n">abs_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">trim_bottom</span>
        <span class="n">abs_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">trim_right</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">abs_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">abs_l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">abs_b</span> <span class="o">-</span> <span class="n">abs_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">abs_r</span> <span class="o">-</span> <span class="n">abs_l</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_mask</span><span class="p">(</span><span class="n">new_mask</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Format the CropObject as its XML representation. See the documentation</span>
<span class="sd">        of :module:`muscima.io` for details.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;CropObject xml:id=&quot;</span><span class="si">{0}</span><span class="s1">&quot;&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Id&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Id&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">))</span>
        <span class="c1"># lines.append(&#39;\t&lt;UniqueId&gt;{0}&lt;/UniqueId&gt;&#39;.format(self.uid))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;MLClassName&gt;</span><span class="si">{0}</span><span class="s1">&lt;/MLClassName&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clsname</span><span class="p">))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Top&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Top&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Left&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Left&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Width&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Width&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Height&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Height&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>

        <span class="n">mask_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Mask&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Mask&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_string</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">inlinks_string</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="p">)))</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Inlinks&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Inlinks&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inlinks_string</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">outlinks_string</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="p">)))</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&lt;Outlinks&gt;</span><span class="si">{0}</span><span class="s1">&lt;/Outlinks&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outlinks_string</span><span class="p">))</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;/CropObject&gt;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<div class="viewcode-block" id="CropObject.encode_mask"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.encode_mask">[docs]</a>    <span class="k">def</span> <span class="nf">encode_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rle&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode a binary array ``mask`` as a string, compliant</span>
<span class="sd">        with the CropObject format specification in :mod:`muscima.io`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;rle&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_mask_rle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bitmap&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_mask_bitmap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CropObject.encode_mask_bitmap"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.encode_mask_bitmap">[docs]</a>    <span class="k">def</span> <span class="nf">encode_mask_bitmap</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encodes the mask array in a compact form. Returns &#39;None&#39; if mask</span>
<span class="sd">        is None. If the mask is not None, uses the following algorithm:</span>

<span class="sd">        * Flatten the mask (then use width and height of CropObject for</span>
<span class="sd">          reshaping).</span>
<span class="sd">        * Record as string, with whitespace separator</span>
<span class="sd">        * Compress string using gz2 (if compress=True) NOT IMPLEMENTED</span>
<span class="sd">        * Return resulting string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;None&#39;</span>
        <span class="c1"># By default works in row-major order.</span>
        <span class="c1"># So we can just prescribe &#39;C&#39; without losing data.</span>
        <span class="n">mask_flat</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">CROPOBJECT_MASK_ORDER</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">mask_flat</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CropObject.encode_mask_rle"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.encode_mask_rle">[docs]</a>    <span class="k">def</span> <span class="nf">encode_mask_rle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encodes the mask array in Run-Length Encoding. Instead of</span>
<span class="sd">        having the bitmap ``0 0 1 1 1 0 0 0 1 1``, the RLE encodes</span>
<span class="sd">        the mask as ``0:2 1:3 0:3 1:2``. This is much more compact.</span>

<span class="sd">        Currently, the rows of the mask are not treated in any special</span>
<span class="sd">        way. The mask just gets flattened and then encoded.</span>

<span class="sd">        Implementation:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;None&#39;</span>
        <span class="n">mask_flat</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">CROPOBJECT_MASK_ORDER</span><span class="p">)</span>

        <span class="n">output_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">current_run_type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current_run_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mask_flat</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">current_run_type</span><span class="p">:</span>
                <span class="n">current_run_length</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">:</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_run_type</span><span class="p">,</span> <span class="n">current_run_length</span><span class="p">)</span>
                <span class="n">output_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">current_run_type</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">current_run_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">:</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">current_run_type</span><span class="p">,</span> <span class="n">current_run_length</span><span class="p">)</span>
        <span class="n">output_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_strings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="CropObject.decode_mask"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.decode_mask">[docs]</a>    <span class="k">def</span> <span class="nf">decode_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_string</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decodes a CropObject mask string into a binary</span>
<span class="sd">        numpy array of the given shape.&quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_mask_mode</span><span class="p">(</span><span class="n">mask_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;rle&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode_mask_rle</span><span class="p">(</span><span class="n">mask_string</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bitmap&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode_mask_bitmap</span><span class="p">(</span><span class="n">mask_string</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_determine_mask_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the mask string starts with &#39;0:&#39; or &#39;1:&#39;, or generally</span>
<span class="sd">        if it contains a non-0 or 1 symbol, assume it is RLE.&quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;bitmap&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask_string</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;bitmap&#39;</span>
        <span class="k">elif</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">mask_string</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;rle&#39;</span>
        <span class="k">return</span> <span class="n">mode</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CropObject.decode_mask_bitmap"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.decode_mask_bitmap">[docs]</a>    <span class="k">def</span> <span class="nf">decode_mask_bitmap</span><span class="p">(</span><span class="n">mask_string</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decodes the mask array from the encoded form to the 2D numpy array.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask_string</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">mask_string</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;CropObject.decode_mask(): Cannot decode mask values:</span><span class="se">\n</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_string</span><span class="p">))</span>
            <span class="k">raise</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1">#s = base64.decodestring(mask_string)</span>
        <span class="c1">#mask = numpy.frombuffer(s)</span>
        <span class="c1">#logging.info(&#39;CropObject.decode_mask(): shape={0}\nmask={1}&#39;.format(mask.shape, mask))</span>
        <span class="k">return</span> <span class="n">mask</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="CropObject.decode_mask_rle"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.decode_mask_rle">[docs]</a>    <span class="k">def</span> <span class="nf">decode_mask_rle</span><span class="p">(</span><span class="n">mask_string</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decodes the mask array from the RLE-encoded form</span>
<span class="sd">        to the 2D numpy array.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask_string</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">kv</span> <span class="ow">in</span> <span class="n">mask_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">):</span>
            <span class="n">k_string</span><span class="p">,</span> <span class="n">v_string</span> <span class="o">=</span> <span class="n">kv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k_string</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">v_string</span><span class="p">)</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
            <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="CropObject.join"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;CropObject &quot;addition&quot;: performs an OR on this</span>
<span class="sd">        and the ``other`` CropObjects&#39; masks and bounding boxes,</span>
<span class="sd">        and assigns to this CropObject the result. Merges</span>
<span class="sd">        also the inlinks and outlinks.</span>

<span class="sd">        Works only if the document spaces for both CropObjects</span>
<span class="sd">        are the same. (Otherwise changes nothing.)</span>

<span class="sd">        The ``clsname`` of the ``other`` is ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Get combined bounding box</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">bottom</span><span class="p">)</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">nh</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">nt</span>
        <span class="n">nw</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">-</span> <span class="n">nl</span>

        <span class="c1"># Create mask of corresponding size</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nh</span><span class="p">,</span> <span class="n">nw</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Find coordinates where to paste the masks</span>
        <span class="n">spt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">nt</span>  <span class="c1"># spt = self_paste_top</span>
        <span class="n">spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">-</span> <span class="n">nl</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">nt</span>
        <span class="n">opl</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span> <span class="o">-</span> <span class="n">nl</span>

        <span class="c1"># Paste the masks into these places</span>
        <span class="n">new_mask</span><span class="p">[</span><span class="n">spt</span><span class="p">:</span><span class="n">spt</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">spl</span><span class="p">:</span><span class="n">spl</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">new_mask</span><span class="p">[</span><span class="n">opt</span><span class="p">:</span><span class="n">opt</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">opl</span><span class="p">:</span><span class="n">opl</span><span class="o">+</span><span class="n">other</span><span class="o">.</span><span class="n">width</span><span class="p">]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">mask</span>

        <span class="c1"># Normalize mask value</span>
        <span class="n">new_mask</span><span class="p">[</span><span class="n">new_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Assign the new variables to this CropObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">nt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">nl</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">nh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">nw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">new_mask</span>

        <span class="c1"># Add inlinks and outlinks (check for multiple and self-reference)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">outlinks</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">o</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">inlinks</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objid</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="CropObject.get_outlink_objects"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.get_outlink_objects">[docs]</a>    <span class="k">def</span> <span class="nf">get_outlink_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropobjects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Out of the given ``cropobject`` list, return a list</span>
<span class="sd">        of those to which this CropObject has outlinks.</span>

<span class="sd">        Can deal with CropObjects from multiple documents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>

        <span class="n">_outlink_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">doc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">objid</span> <span class="ow">in</span> <span class="n">_outlink_set</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outlinks</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="CropObject.get_inlink_objects"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.CropObject.get_inlink_objects">[docs]</a>    <span class="k">def</span> <span class="nf">get_inlink_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cropobjects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Out of the given ``cropobject`` list, return a list</span>
<span class="sd">        of those from which this CropObject has inlinks.</span>

<span class="sd">        Can deal with CropObjects from multiple documents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>

        <span class="n">_inlink_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">doc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">objid</span> <span class="ow">in</span> <span class="n">_inlink_set</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inlinks</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">output</span></div></div>


<span class="c1">##############################################################################</span>
<span class="c1"># Functions for merging CropObjects and CropObjectLists</span>

<div class="viewcode-block" id="cropobjects_merge_bbox"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.cropobjects_merge_bbox">[docs]</a><span class="k">def</span> <span class="nf">cropobjects_merge_bbox</span><span class="p">(</span><span class="n">cropobjects</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the bounding box of a CropObject that would</span>
<span class="sd">    result from merging the given list of CropObjects.&quot;&quot;&quot;</span>
    <span class="c1"># Find extremes. This will define the output cropobject.</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">bottom</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span></div>


<div class="viewcode-block" id="cropobjects_merge_mask"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.cropobjects_merge_mask">[docs]</a><span class="k">def</span> <span class="nf">cropobjects_merge_mask</span><span class="p">(</span><span class="n">cropobjects</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merges the given list of cropobjects into one. Masks are combined</span>
<span class="sd">    by an OR operation.</span>

<span class="sd">    &gt;&gt;&gt; c1 = CropObject(0, &#39;name&#39;, 10, 10, 4, 1, mask=numpy.ones((1, 4), dtype=&#39;uint8&#39;))</span>
<span class="sd">    &gt;&gt;&gt; c2 = CropObject(1, &#39;name&#39;, 11, 10, 6, 1, mask=numpy.ones((1, 6), dtype=&#39;uint8&#39;))</span>
<span class="sd">    &gt;&gt;&gt; c3 = CropObject(2, &#39;name&#39;, 9, 14,  2, 4, mask=numpy.ones((4, 2), dtype=&#39;uint8&#39;))</span>
<span class="sd">    &gt;&gt;&gt; c = [c1, c2, c3]</span>
<span class="sd">    &gt;&gt;&gt; m1 = cropobjects_merge_mask(c)</span>
<span class="sd">    &gt;&gt;&gt; m1.shape</span>
<span class="sd">    (4, 6)</span>
<span class="sd">    &gt;&gt;&gt; print(m1)</span>
<span class="sd">    [[0 0 0 0 1 1]</span>
<span class="sd">     [1 1 1 1 1 1]</span>
<span class="sd">     [1 1 1 1 1 1]</span>
<span class="sd">     [0 0 0 0 1 1]]</span>

<span class="sd">    Mask behavior: if at least one of the cropobjects has a mask, then</span>
<span class="sd">    masking behavior is activated. The masks are combined using OR: any</span>
<span class="sd">    pixel of the resulting merged cropobject that corresponds to a True</span>
<span class="sd">    mask pixel in one of the input cropobjects will get a True mask value,</span>
<span class="sd">    all others (ie. including all intermediate areas) will get a False.</span>

<span class="sd">    If no input cropobject has a mask, then the resulting cropobject</span>
<span class="sd">    also will not have a mask.</span>

<span class="sd">    If some cropobjects have masks and some don&#39;t, fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># No mask</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Some masked, some not</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot deal with a mix of masked and non-masked cropobjects.&#39;</span><span class="p">)</span>

    <span class="c1"># Now we know all have masks.</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cropobjects_merge_bbox</span><span class="p">(</span><span class="n">cropobjects</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">t</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span>
    <span class="n">output_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cropobjects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1">#logging.warn(&#39;Output mask shape: {0}&#39;.format(output_mask.shape))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">:</span>
        <span class="c1">#logging.debug(&#39;C. shape: {0}&#39;.format(c.bounding_box))</span>
        <span class="c1">#logging.debug(&#39;TLBR: {0}&#39;.format((t, l, b, r)))</span>
        <span class="n">ct</span><span class="p">,</span> <span class="n">cl</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cr</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">left</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">bottom</span><span class="p">),</span> <span class="n">w</span> <span class="o">-</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="c1">#logging.debug(&#39;Mask shape: {0}, curr. shape: {1}&#39;.format(c.mask.shape, (cb - ct, cr - cl)))</span>
        <span class="n">output_mask</span><span class="p">[</span><span class="n">ct</span><span class="p">:</span><span class="n">cb</span><span class="p">,</span> <span class="n">cl</span><span class="p">:</span><span class="n">cr</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span><span class="o">.</span><span class="n">mask</span>

    <span class="n">output_mask</span><span class="p">[</span><span class="n">output_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">output_mask</span></div>


<div class="viewcode-block" id="cropobjects_merge_links"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.cropobjects_merge_links">[docs]</a><span class="k">def</span> <span class="nf">cropobjects_merge_links</span><span class="p">(</span><span class="n">cropobjects</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Collect all inlinks and outlinks of the given set of CropObjects</span>
<span class="sd">    to CropObjects outside of this set. The rationale for this is that</span>
<span class="sd">    these given ``cropobjects`` will be merged into one, so relationships</span>
<span class="sd">    within the set would become loops and disappear.</span>

<span class="sd">    (Note that this is not sufficient to update the relationships upon</span>
<span class="sd">    a merge, because the affected CropObjects *outside* the given set</span>
<span class="sd">    will need to have their inlinks/outlinks redirected to the new object.)</span>

<span class="sd">    :returns: A tuple of lists: ``(inlinks, outlinks)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_internal_objids</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">objid</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">])</span>
    <span class="n">outlinks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">inlinks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobjects</span><span class="p">:</span>
        <span class="c1"># No duplicates</span>
        <span class="n">outlinks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">outlinks</span>
                         <span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_internal_objids</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">o</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outlinks</span><span class="p">)])</span>
        <span class="n">inlinks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">inlinks</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_internal_objids</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inlinks</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">inlinks</span><span class="p">,</span> <span class="n">outlinks</span></div>


<div class="viewcode-block" id="merge_cropobject_lists"><a class="viewcode-back" href="../../muscima.cropobject.html#muscima.cropobject.merge_cropobject_lists">[docs]</a><span class="k">def</span> <span class="nf">merge_cropobject_lists</span><span class="p">(</span><span class="o">*</span><span class="n">cropobject_lists</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combines the CropObject lists from different documents</span>
<span class="sd">    into one list, so that inlink/outlink references still work.</span>
<span class="sd">    This is useful only if you want to merge two documents</span>
<span class="sd">    into one (e.g., if your annotators worked on different &quot;layers&quot;</span>
<span class="sd">    of data, and you want to merge these annotations).</span>

<span class="sd">    This just means shifting the ``objid`` (and thus inlinks</span>
<span class="sd">    and outlinks). It is assumed the lists pertain to the same</span>
<span class="sd">    image. Uses deepcopy to avoid exposing the original lists</span>
<span class="sd">    to modification through the merged list.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        If you are ever exporting the merged list, make sure to</span>
<span class="sd">        set the ``uid`` for the outputs correctly, if you want</span>
<span class="sd">        to create a new document.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cropobject_lists</span><span class="p">]</span>
    <span class="n">shift_by</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">lengths</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">))]</span>

    <span class="n">new_lists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">clist</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cropobject_lists</span><span class="p">,</span> <span class="n">shift_by</span><span class="p">):</span>
        <span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clist</span><span class="p">:</span>
            <span class="n">new_c</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">new_c</span><span class="o">.</span><span class="n">objid</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">objid</span> <span class="o">+</span> <span class="n">s</span>
            <span class="n">new_c</span><span class="o">.</span><span class="n">inlinks</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">inlinks</span><span class="p">]</span>
            <span class="n">new_c</span><span class="o">.</span><span class="n">outlinks</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">outlinks</span><span class="p">]</span>
            <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_c</span><span class="p">)</span>
        <span class="n">new_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">new_lists</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">output</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Author.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>